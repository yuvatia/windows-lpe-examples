#include <Windows.h>


typedef struct _LARGE_UNICODE_STRING
{
	ULONG Length;           // 000
	ULONG MaximumLength : 31; // 004
	ULONG bAnsi : 1;          // 004
	PWSTR Buffer;           // 008
} LARGE_UNICODE_STRING, *PLARGE_UNICODE_STRING;


typedef struct _THRDESKHEAD {
	HWND h;
	unsigned long cLockObj;
	void* pti;
	void* rpdesk;
	_THRDESKHEAD* pSelf;
} THRDESKHEAD;


typedef struct tagCLS {
	tagCLS*       pclsNext;
	ATOM          atomClassName;
	WORD          fnid;
	void*		  rpdeskParent;
	void*         pdce;
	WORD          hTaskWow;
	WORD          CSF_flags;
	LPSTR         lpszClientAnsiMenuName;
	LPWSTR        lpszClientUnicodeMenuName;
	void*		  spcpdFirst;
	tagCLS*       pclsBase;
	tagCLS*       pclsClone;
	int           cWndReferenceCount;
	UINT          style;
	WNDPROC       lpfnWndProc;
	int           cbclsExtra;
	int           cbwndExtra;
	HMODULE       hModule;
	void*		   spicn;
	void*	       spcur;
	// RS3: Uncomment buffer2.
	// RS2: Comment buffer2.
	void* buffer;
	//void* buffer2;
	HBRUSH        hbrBackground;
	LPWSTR        lpszMenuName;
	LPSTR         lpszAnsiClassName;
	void*         spicnSm;
} CLS, *PCLS;


typedef struct tagWND {
	THRDESKHEAD          head;
	DWORD                dwState;
	DWORD                dwState2;
	DWORD                dwExStyle;
	DWORD                dwStyle;
	HMODULE              hModule;
	WORD                 hMod16;
	WORD                 fnid;
	tagWND*               spwndNext;
	tagWND*               spwndParent;
	tagWND*               spwndChild;
	tagWND*               spwndOwner;
	RECT                 rcWindow;
	RECT                 rcClient;
	WNDPROC              lpfnWndProc;
	void* buffer;
	void* buffer2;
	void* buffer3;
	PCLS                 pcls;
	HRGN                 hrgnUpdate;
	void*                ppropList;
	void*                pSBInfo;
	void*                spmenuSys;
	void*                spmenu;
	HRGN                 hrgnClip;
	LARGE_UNICODE_STRING strName;
	int                  cbwndExtra;
	tagWND*              spwndLastActive;
	HIMC                 hImc;
	ULONG_PTR            dwUserData;
	DWORD                field1;
	DWORD                field2;
} WND, *PWND;

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG NumberOfModules;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _GDICELL {
	LPVOID pKernelAddress;
	USHORT wProcessId;
	USHORT wCount;
	USHORT wUpper;
	USHORT wType;
	LPVOID pUserAddress;
} GDICELL, *PGDICELL;

typedef struct _SERVERINFO {
	DWORD dwSRVIFlags;
	DWORD cHandleEntries;
	WORD wSRVIFlags;
	WORD wRIPPID;
	WORD wRIPError;
} SERVERINFO, *PSERVERINFO;

typedef struct _USER_HANDLE_ENTRY {
	void    *pKernel;
	union
	{
		PVOID pi;
		PVOID pti;
		PVOID ppi;
	};
	BYTE type;
	BYTE flags;
	WORD generation;
} USER_HANDLE_ENTRY, *PUSER_HANDLE_ENTRY;

typedef struct _SHAREDINFO {
	PSERVERINFO psi;
	PUSER_HANDLE_ENTRY aheList;
	ULONG HeEntrySize;
	ULONG_PTR pDispInfo;
	ULONG_PTR ulSharedDelts;
	ULONG_PTR awmControl;
	ULONG_PTR DefWindowMsgs;
	ULONG_PTR DefWindowSpecMsgs;
} SHAREDINFO, *PSHAREDINFO;

typedef struct _LeakBitmapInfo {
	HBITMAP hBitmap;
	PUCHAR pBitmapPvScan0;
} LeakBitmapInfo, *pLeakBitmapInfo;


typedef struct tagQMSG {
	struct tagQMSG  *pqmsgNext;
	struct tagQMSG  *pqmsgPrev;
	MSG             msg;
	LONG            ExtraInfo;
	DWORD           dwQEvent;
	void*     pti;
	//PTHREADINFO     pti;
} QMSG, *PQMSG;

/*
* dwQEvent values for QMSG structure.
*/
#define QEVENT_SHOWWINDOW           0x0001
#define QEVENT_CANCELMODE           0x0002
#define QEVENT_SETWINDOWPOS         0x0003
#define QEVENT_UPDATEKEYSTATE       0x0004
#define QEVENT_DEACTIVATE           0x0005
#define QEVENT_ACTIVATE             0x0006
#define QEVENT_POSTMESSAGE          0x0007  // Chicago
#define QEVENT_EXECSHELL            0x0008  // Chicago
#define QEVENT_CANCELMENU           0x0009  // Chicago
#define QEVENT_DESTROYWINDOW        0x000A
#define QEVENT_ASYNCSENDMSG         0x000B

/*
* xxxProcessEventMessage flags
*/
#define PEM_ACTIVATE_RESTORE        0x0001
#define PEM_ACTIVATE_NOZORDER       0x0002

#define QMF_MAXEVENT                0x000F

typedef struct _MOVESIZEDATA {
	struct tagWND  *spwnd;
	RECT            rcDrag;
	RECT            rcDragCursor;
	RECT            rcParent;
	POINT           ptMinTrack;
	POINT           ptMaxTrack;
	RECT            rcWindow;
	int             dxMouse;
	int             dyMouse;
	int             cmd;
	int             impx;
	int             impy;
	POINT           ptRestore;
	UINT            fInitSize : 1;    // should we initialize cursor pos
	UINT            fmsKbd : 1;    // who knows
	UINT            fLockWindowUpdate : 1;    // whether screen was locked ok
	UINT            fTrackCancelled : 1;    // Set if tracking ended by other thread.
	UINT            fForeground : 1;    // whether the tracking thread is foreground
										//  and if we should draw the drag-rect
	UINT            fDragFullWindows : 1;
	UINT            fOffScreen : 1;
} MOVESIZEDATA, *PMOVESIZEDATA;

/*
* DrawDragRect styles.
*/
#define DDR_START     0     // - start drag.
#define DDR_ENDACCEPT 1     // - end and accept
#define DDR_ENDCANCEL 2     // - end and cancel.

typedef struct tagMLIST {
	PQMSG pqmsgRead;
	PQMSG pqmsgWriteLast;
	DWORD cMsgs;
} MLIST, *PMLIST;

/*
* Message Queue structure.
*/
#define CVKKEYSTATE                 256
#define CBKEYSTATE                  (CVKKEYSTATE >> 2)
#define CBKEYSTATERECENTDOWN        (CVKKEYSTATE >> 3)

#ifndef _WIN64
typedef UCHAR TLSPRITESTATE[0x60];
typedef UCHAR tagCARET[0x38];
#else
typedef UCHAR TLSPRITESTATE[0xA8];
typedef UCHAR tagCARET[0x44];
#endif
typedef tagCARET CARET;

typedef struct tagQ {
	MLIST       mlInput;            // raw mouse and key message list.

	void* ptiSysLock;         // Thread currently allowed to process input
	//PTHREADINFO ptiSysLock;         // Thread currently allowed to process input
	DWORD       idSysLock;          // Last message removed
	DWORD       idSysPeek;          // Last message peeked

	void* ptiMouse;           // Last thread to get mouse msg.
	void* ptiKeyboard;
	//PTHREADINFO ptiMouse;           // Last thread to get mouse msg.
	//PTHREADINFO ptiKeyboard;

	PWND        spwndCapture;
	PWND        spwndFocus;
	PWND        spwndActive;
	PWND        spwndActivePrev;

	UINT        codeCapture;
	UINT        msgDblClk;
	DWORD       timeDblClk;
	HWND        hwndDblClk;
	RECT        rcDblClk;

	BYTE        afKeyRecentDown[CBKEYSTATERECENTDOWN];
	BYTE        afKeyState[CBKEYSTATE];

	PWND        spwndAltTab;

	CARET       caret;

	void* spcurCurrent;
	//PCURSOR     spcurCurrent;
	int         iCursorLevel;

	DWORD       QF_flags;            // QF_ flags go here

	USHORT      cThreads;            // Count of threads using this queue
	USHORT      cLockCount;          // Count of threads that don't want this queue freed

	UINT        msgJournal;
	HCURSOR     hcurCurrent;
	LONG        ExtraInfo;

	PWND        spwndLastMouseMessage;
	RECT        rcMouseHover;
	DWORD       dwMouseHoverTime;
} Q, *PQ;
